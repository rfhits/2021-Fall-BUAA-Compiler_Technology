# 词法分析

## 最初设计

封装`Token`类，成员变量有token的值以及类别码等。

完成一个`get_token`函数，每次调用该函数，就能返回一个token。

`get_token()`内部采用多个if-else分支，连续读取识别并判断是否为保留字；连续读取整数；采用预读取判断是否为`||, &&, !=`等二元分隔符；对于简单的字符如`+, -, *`等，返回其对应的类型。

在主程序中循环调用该函数，不断获取token，输出其类别码和值，直到读到文件的末尾。

## 修改情况

首先是预处理，将文件中所有的注释都替换为空格。

在token类的基础上，封装`Lexer`类，作为词法分析器。

```cpp
class Lexer {
public:
    char ch; // 正在处理的字符
    string token; // 
    string source;
    int pos = 0; // in source[0]
    int line_no = 1; // no at this line
    int col_no = 1; // not at the column
    static map<string, string> reserved_words_map;
    static map<string, string> single_char_map;
    int get_char();
    Token get_token();
    void pre_treat();
    void retract();
}
```

开始时就将文件读入字符串source中，此后，每当要`get_token()`时，就不断调用`get_char()`，读取匹配到的字符串，然后，利用`Lexer`内部的Map变量，将一些特殊的token如`+, -, *`直接映射到其类别码上，存储到成员变量token中。

当然，在词法分析的过程中还可能发生以下错误：

+ 预读字符与期待字符不同
+ token的值无法匹配到任何已知的类别码
+ 读取到未知字符

因此，还封装了`Error`类，当错误发生时，就输出相应的错误信息以及`Lexer`类正在处理的行号与列号，这也是为什么在前面不直接删除注释而是将其替换为空格的原因。









