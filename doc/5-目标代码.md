# 目标代码

有几个前提我们要知道：

1. 所有变量的名字看起来都不一样。

    给定一个变量名字和其所在的function和level，我们就能知道它相对于函数头所在地址的偏移。

2. 每个函数生成了中间代码，我们就知道它运行栈大小。

    换而言之，我们知道了这个函数运行需要多少内存。

    这是确定一个函数中变量地址的基础。

3. 



## 接口设计

### 寄存器

存储寄存器中存了哪些变量的值，有s_old和



## MIPS指令

### 操作数

How do we represent a number/variable/offset/address/label in MIPS code?







### 算数

```asm
add $t1,$t2,$t3
Addition with overflow : set $t1 to ($t2 plus $t3)

addi $t1,$t2,-100
Addition immediate with overflow : set $t1 to ($t2 plus signed 16-bit immediate)

sub $t1,$t2,$t3
Subtraction with overflow : set $t1 to ($t2 minus $t3)

mul $t1,$t2,$t3
Multiplication without overflow  : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and $t3 (use mfhi to access HI, mflo to access LO)

mult $t1,$t2
Multiplication : Set hi to high-order 32 bits, lo to low-order 32 bits of the product of $t1 and $t2 (use mfhi to access hi, mflo to access lo)

div $t1,$t2
Division with overflow : Divide $t1 by $t2 then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)

mfhi $t1
Move from HI register : Set $t1 to contents of HI (see multiply and divide operations)

mflo $t1
Move from LO register : Set $t1 to contents of LO (see multiply and divide operations)

mthi $t1
Move to HI registerr : Set HI to contents of $t1 (see multiply and divide operations)

mtlo $t1
Move to LO register : Set LO to contents of $t1 (see multiply and divide operations)


lui $t1,100
Load upper immediate : Set high-order 16 bits of $t1 to 16-bit immediate and low-order 16 bits to 0

# -- derivatives --


add $t1,$t2,-100
ADDition : set $t1 to ($t2 plus 16-bit immediate)

add $t1,$t2,100000
ADDition : set $t1 to ($t2 plus 32-bit immediate)

addi $t1,$t2,100000
ADDition Immediate : set $t1 to ($t2 plus 32-bit immediate)

addiu $t1,$t2,100000
ADDition Immediate Unsigned: set $t1 to ($t2 plus 32-bit immediate), no overflow

addu $t1,$t2,100000
ADDition Unsigned : set $t1 to ($t2 plus 32-bit immediate), no overflow

sub $t1,$t2,-100
SUBtraction : set $t1 to ($t2 minus 16-bit immediate)

sub $t1,$t2,100000
SUBtraction : set $t1 to ($t2 minus 32-bit immediate)

subi $t1,$t2,-100
SUBtraction Immediate : set $t1 to ($t2 minus 16-bit immediate)

subi $t1,$t2,100000
SUBtraction Immediate : set $t1 to ($t2 minus 32-bit immediate)

mul $t1,$t2,-100
MULtiplication : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and 16-bit signed immediate (use mfhi to access HI, mflo to access LO)

mul $t1,$t2,100000
MULtiplication : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and 32-bit immediate (use mfhi to access HI, mflo to access LO)

div $t1,$t2,$t3
DIVision : Set $t1 to ($t2 divided by $t3, integer division)

div $t1,$t2,-100
DIVision : Set $t1 to ($t2 divided by 16-bit immediate, integer division)

div $t1,$t2,100000
DIVision : Set $t1 to ($t2 divided by 32-bit immediate, integer division)

li $t1,-100
Load Immediate : Set $t1 to 16-bit immediate (sign-extended)

li $t1,100
Load Immediate : Set $t1 to unsigned 16-bit immediate (zero-extended)

li $t1,100000
Load Immediate : Set $t1 to 32-bit immediate
```

### 位运算（bitwise）

```asm
and $t1,$t2,$t3
Bitwise AND : Set $t1 to bitwise AND of $t2 and $t3

andi $t1,$t2,100
Bitwise AND immediate : Set $t1 to bitwise AND of $t2 and zero-extended 16-bit immediate

nor $t1,$t2,$t3
Bitwise NOR : Set $t1 to bitwise NOR of $t2 and $t3

or $t1,$t2,$t3
Bitwise OR : Set $t1 to bitwise OR of $t2 and $t3

ori $t1,$t2,100
Bitwise OR immediate : Set $t1 to bitwise OR of $t2 and zero-extended 16-bit immediate

sll $t1,$t2,10
Shift left logical : Set $t1 to result of shifting $t2 left by number of bits specified by immediate

sllv $t1,$t2,$t3
Shift left logical variable : Set $t1 to result of shifting $t2 left by number of bits specified by value in low-order 5 bits of $t3

sra $t1,$t2,10
Shift right arithmetic : Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by immediate

srav $t1,$t2,$t3
Shift right arithmetic variable : Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3

srl $t1,$t2,10
Shift right logical : Set $t1 to result of shifting $t2 right by number of bits specified by immediate

srlv $t1,$t2,$t3
Shift right logical variable : Set $t1 to result of shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3

# derivatives

and $t1,$t2,100
AND : set $t1 to ($t2 bitwise-AND 16-bit unsigned immediate)

and $t1,100
AND : set $t1 to ($t1 bitwise-AND 16-bit unsigned immediate)

andi $t1,$t2,100000
AND Immediate : set $t1 to ($t2 bitwise-AND 32-bit immediate)

andi $t1,100
AND Immediate : set $t1 to ($t1 bitwise-AND 16-bit unsigned immediate)

andi $t1,100000
AND Immediate : set $t1 to ($t1 bitwise-AND 32-bit immediate)

not $t1,$t2
Bitwise NOT (bit inversion)

or $t1,$t2,100
OR : set $t1 to ($t2 bitwise-OR 16-bit unsigned immediate)

or $t1,100
OR : set $t1 to ($t1 bitwise-OR 16-bit unsigned immediate)

ori $t1,$t2,100000
OR Immediate : set $t1 to ($t2 bitwise-OR 32-bit immediate)

ori $t1,100
OR Immediate : set $t1 to ($t1 bitwise-OR 16-bit unsigned immediate)

ori $t1,100000
OR Immediate : set $t1 to ($t1 bitwise-OR 32-bit immediate)
```



### 比较指令（compare）

```asm
slt $t1,$t2,$t3
Set less than : If $t2 is less than $t3, then set $t1 to 1 else set $t1 to 0

slti $t1,$t2,-100
Set less than immediate : If $t2 is less than sign-extended 16-bit immediate, then set $t1 to 1 else set $t1 to 0

# derivatives
seq $t1,$t2,$t3
Set EQual : if $t2 equal to $t3 then set $t1 to 1 else 0

seq $t1,$t2,-100
Set EQual : if $t2 equal to 16-bit immediate then set $t1 to 1 else 0

seq $t1,$t2,100000
Set EQual : if $t2 equal to 32-bit immediate then set $t1 to 1 else 0

sne $t1,$t2,$t3
Set Not Equal : if $t2 not equal to $t3 then set $t1 to 1 else 0

sne $t1,$t2,-100
Set Not Equal : if $t2 not equal to 16-bit immediate then set $t1 to 1 else 0

sne $t1,$t2,100000 
Set Not Equal : if $t2 not equal to 32-bit immediate then set $t1 to 1 else 0

sle $t1,$t2,$t3 
Set Less or Equal : if $t2 less or equal to $t3 then set $t1 to 1 else 0

sle $t1,$t2,-100
Set Less or Equal : if $t2 less or equal to 16-bit immediate then set $t1 to 1 else 0

sle $t1,$t2,100000
Set Less or Equal : if $t2 less or equal to 32-bit immediate then set $t1 to 1 else 0

sgt $t1,$t2,$t3
Set Greater Than : if $t2 greater than $t3 then set $t1 to 1 else 0

sgt $t1,$t2,-100
Set Greater Than : if $t2 greater than 16-bit immediate then set $t1 to 1 else 0

sgt $t1,$t2,100000
Set Greater Than : if $t2 greater than 32-bit immediate then set $t1 to 1 else 0

sge $t1,$t2,$t3
Set Greater or Equal : if $t2 greater or equal to $t3 then set $t1 to 1 else 0

sge $t1,$t2,-100
Set Greater or Equal : if $t2 greater or equal to 16-bit immediate then set $t1 to 1 else 0

sge $t1,$t2,100000
Set Greater or Equal : if $t2 greater or equal to 32-bit immediate then set $t1 to 1 else 0
```

`slt`严格区分整数和寄存器

### 访存（memory access）

```asm

lw $t1,-100($t2)
Load word : Set $t1 to contents of effective memory word address

sw $t1,-100($t2)
Store word : Store contents of $t1 into effective memory word address

# derivatives

sw $t1,($t2)
Store Word : Store $t1 contents into effective memory word address

sw $t1,-100
Store Word : Store $t1 contents into effective memory word address

sw $t1,100
Store Word : Store $t1 contents into effective memory word address

sw $t1,100($t2)
Store Word : Store $t1 contents into effective memory word address

sw $t1,100000
Store Word : Store $t1 contents into effective memory word address

sw $t1,100000($t2)
Store Word : Store $t1 contents into effective memory word address

sw $t1,label
Store Word : Store $t1 contents into memory word at label's address

sw $t1,label($t2)
Store Word : Store $t1 contents into effective memory word address

sw $t1,label+100000
Store Word : Store $t1 contents into effective memory word address

sw $t1,label+100000($t2)
Store Word : Store $t1 contents into effective memory word address


lw $t1,($t2)
Load Word : Set $t1 to contents of effective memory word address

lw $t1,-100
Load Word : Set $t1 to contents of effective memory word address

lw $t1,100
Load Word : Set $t1 to contents of effective memory word address

lw $t1,100($t2)
Load Word : Set $t1 to contents of effective memory word address

lw $t1,100000
Load Word : Set $t1 to contents of effective memory word address

lw $t1,100000($t2)
Load Word : Set $t1 to contents of effective memory word address

lw $t1,label
Load Word : Set $t1 to contents of memory word at label's address

lw $t1,label($t2)
Load Word : Set $t1 to contents of effective memory word address

lw $t1,label+100000
Load Word : Set $t1 to contents of effective memory word address 

lw $t1,label+100000($t2)
Load Word : Set $t1 to contents of effective memory word address
```

### 分支/跳转（branch/jump）

```asm
beq $t1,$t2,label
Branch if equal : Branch to statement at label's address if $t1 and $t2 are equal

bne $t1,$t2,label
Branch if not equal : Branch to statement at label's address if $t1 and $t2 are not equal

j target
Jump unconditionally : Jump to statement at target address

jal target
Jump and link : Set $ra to Program Counter (return address) then jump to statement at target address

jr $t1
Jump register unconditionally : Jump to statement whose address is in $t1

# derivatives

b label
Branch : Branch to statement at label unconditionally

beq $t1,-100,label
Branch if EQual : Branch to statement at label if $t1 is equal to 16-bit immediate

beq $t1,100000,label
Branch if EQual : Branch to statement at label if $t1 is equal to 32-bit immediate

bne $t1,-100,label
Branch if Not Equal : Branch to statement at label if $t1 is not equal to 16-bit immediate

bne $t1,100000,label
Branch if Not Equal : Branch to statement at label if $t1 is not equal to 32-bit immediate

bnez $t1,label
Branch if Not Equal Zero : Branch to statement at label if $t1 is not equal to zero
```



### IO

```asm
syscall
Issue a system call : Execute the system call specified by value in $v0
```

## 具体翻译实现

### 接口设计

### 内存分配

我们可以给变量分下类：

1. `global`和`local`
2. `const`和`var`
3. `value`和`array`

我们可以使用的存储空间有：

1. `$gp`
2. `$sp`
3. `.data`
4. `reg`

global直接存入data中

### 寄存器分配策略

#### a_reg

a0：函数参数值的计算或者地址的计算

a1：减法中被减数，除法中被除数

#### t_reg

t寄存器用于存储函数运行的临时变量，其特点是，

1. 在add，sub，mul，div运算中，若其不作为dst，那么只会出现一次，然后被抛弃，不需要回写。

```asm
add t0 t1 t2 # t1 and t2 can be released now

add t0 t0 1 # t0 shouldn't be released
```

2. 在PUSH_VAL 操作中，作为参数，使用后可以直接销毁，不用回写
3. 

若reg中已经满了，那么才需要回写。

#### s_reg

### 算数指令



除法中，若被除数是整数，因为那么就使用`$a0`来放这个被除数

### 数组存取

```asm
.text
	li	$t0, 1
	sw	$t0, 4($gp)
	li	$a0, 4
	add	$a0, $a0, $gp
	lw	$t1, 0($a0)
```

使用`$a0`来存储绝对地址



### 函数调用



```cpp

int f1(int a) {
    return 0;
}

int f2(int a) {
    return 0;
}

int main() {
    f2(f1(a));
    return 0;
}
```



### 输出

```asm
.data
	str_1:	.asciiz "hello world"
	str_2: 	.asciiz "\n"
	
.text
	la $a0, str_1
	li $v0, 4
	syscall
```



## 在此分支上的bug

不要忘记添加到readme中

+ const init时，insert顺序反了

+ gp没自减

+ 别开延迟槽

+ 为一个symbol分配reg时，调整fifo的order

+ 将数组的地址存到reg中，因为parameter的arr中无法通过`$sp`加偏移的方式直接访问

+ bigbug: 使用了vector后，再取vector中的地址，然后对vector进行push_back，结果地址变了。
    https://stackoverflow.com/questions/641864/returning-a-pointer-to-a-vector-element-in-c
    
    此问题似乎无解，最终让我使用了拷贝
    
+ 中间代码把关键代码写到if-error的语句块里了

    

    ```cpp
    if (!symbol_table_.AddSymbol(cur_func_name_, param_type, SymbolType::PARAM,
                                         name_, alias_,
                                         param_ord, cur_level_, dims_, dim0_size_, dim1_size_, local_addr_)) {
                add_error(ErrorType::REDEF);
        		local_addr += 4;
            }
    ```

    ```cpp
    sum(int a, int b) {
        return a+b;
    }
    int main() {
    	int c = sum(2,4);
        // cout c
    }
    
    ```

    

+ 栈自减的时候，sub负数了

    ```cpp
    if (op == IntermOp::PREPARE_CALL) {
        // sp minus (context and func size), it's denoted "frame size"
        // then save the context: ra, sp, s_res, t_res
        cur_callee_name_ = dst;
        int func_stack_size = symbol_table_.get_func_stack_size(dst);
        int frame_size = context_size + func_stack_size;
        frame_size_stack_.push_back(frame_size);
        add_code("sub $sp, $sp, -" + std::to_string(frame_size));
    }
    ```

+ fifo是真滴难写，我好像写成LRU了

## 参考资料

[MIPS语法教学](https://www.cnblogs.com/thoupin/p/4018455.html)

[函数调用](https://blog.csdn.net/do2jiang/article/details/5404566)



