# 目标代码

有几个前提我们要知道：

1. 所有变量的名字看起来都不一样。

    给定一个变量名字和其所在的function和level，我们就能知道它相对于函数头所在地址的偏移。

2. 每个函数生成了中间代码，我们就知道它运行栈大小。

    换而言之，我们知道了这个函数运行需要多少内存。

    这是确定一个函数中变量地址的基础。

3. 

## 内存分配

我们可以给变量分下类：

1. `global`和`local`
2. `const`和`var`
3. `value`和`array`

我们可以使用的存储空间有：

1. `$gp`
2. `$sp`
3. `.data`
4. `reg`

global直接存入data中

## 函数调用约定

## MIPS指令

### 操作数

How do we represent a number/variable/offset/address/label in MIPS code?







### 算数

```asm
add $t1,$t2,$t3
Addition with overflow : set $t1 to ($t2 plus $t3)

addi $t1,$t2,-100
Addition immediate with overflow : set $t1 to ($t2 plus signed 16-bit immediate)

sub $t1,$t2,$t3
Subtraction with overflow : set $t1 to ($t2 minus $t3)

div $t1,$t2
Division with overflow : Divide $t1 by $t2 then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)

mfhi $t1
Move from HI register : Set $t1 to contents of HI (see multiply and divide operations)

mflo $t1
Move from LO register : Set $t1 to contents of LO (see multiply and divide operations)

mthi $t1
Move to HI registerr : Set HI to contents of $t1 (see multiply and divide operations)

mtlo $t1
Move to LO register : Set LO to contents of $t1 (see multiply and divide operations)

mul $t1,$t2,$t3
Multiplication without overflow  : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and $t3 (use mfhi to access HI, mflo to access LO)

mult $t1,$t2
Multiplication : Set hi to high-order 32 bits, lo to low-order 32 bits of the product of $t1 and $t2 (use mfhi to access hi, mflo to access lo)

lui $t1,100
Load upper immediate : Set high-order 16 bits of $t1 to 16-bit immediate and low-order 16 bits to 0

# -- derivatives --


add $t1,$t2,-100
ADDition : set $t1 to ($t2 plus 16-bit immediate)

add $t1,$t2,100000
ADDition : set $t1 to ($t2 plus 32-bit immediate)

addi $t1,$t2,100000
ADDition Immediate : set $t1 to ($t2 plus 32-bit immediate)

addiu $t1,$t2,100000
ADDition Immediate Unsigned: set $t1 to ($t2 plus 32-bit immediate), no overflow

addu $t1,$t2,100000
ADDition Unsigned : set $t1 to ($t2 plus 32-bit immediate), no overflow

div $t1,$t2,$t3
DIVision : Set $t1 to ($t2 divided by $t3, integer division)

div $t1,$t2,-100
DIVision : Set $t1 to ($t2 divided by 16-bit immediate, integer division)

div $t1,$t2,100000
DIVision : Set $t1 to ($t2 divided by 32-bit immediate, integer division)

divu $t1,$t2,$t3
DIVision Unsigned :  Set $t1 to ($t2 divided by $t3, unsigned integer division)

divu $t1,$t2,-100
DIVision Unsigned :  Set $t1 to ($t2 divided by 16-bit immediate, unsigned integer division)

divu $t1,$t2,100000
DIVision Unsigned :  Set $t1 to ($t2 divided by 32-bit immediate, unsigned integer division)

mul $t1,$t2,-100
MULtiplication : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and 16-bit signed immediate (use mfhi to access HI, mflo to access LO)

mul $t1,$t2,100000
MULtiplication : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and 32-bit immediate (use mfhi to access HI, mflo to access LO)

sub $t1,$t2,-100
SUBtraction : set $t1 to ($t2 minus 16-bit immediate)

sub $t1,$t2,100000
SUBtraction : set $t1 to ($t2 minus 32-bit immediate)

subi $t1,$t2,-100
SUBtraction Immediate : set $t1 to ($t2 minus 16-bit immediate)

subi $t1,$t2,100000
SUBtraction Immediate : set $t1 to ($t2 minus 32-bit immediate)

subiu $t1,$t2,100000
SUBtraction Immediate Unsigned : set $t1 to ($t2 minus 32-bit immediate), no overflow

subu $t1,$t2,100000
SUBtraction Unsigned : set $t1 to ($t2 minus 32-bit immediate), no overflow


li $t1,-100
Load Immediate : Set $t1 to 16-bit immediate (sign-extended)

li $t1,100
Load Immediate : Set $t1 to unsigned 16-bit immediate (zero-extended)

li $t1,100000
Load Immediate : Set $t1 to 32-bit immediate
```

### 位运算（bitwise）

```asm
and $t1,$t2,$t3
Bitwise AND : Set $t1 to bitwise AND of $t2 and $t3

andi $t1,$t2,100
Bitwise AND immediate : Set $t1 to bitwise AND of $t2 and zero-extended 16-bit immediate

sll $t1,$t2,10
Shift left logical : Set $t1 to result of shifting $t2 left by number of bits specified by immediate

sllv $t1,$t2,$t3
Shift left logical variable : Set $t1 to result of shifting $t2 left by number of bits specified by value in low-order 5 bits of $t3

sra $t1,$t2,10
Shift right arithmetic : Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by immediate

srav $t1,$t2,$t3
Shift right arithmetic variable : Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3

srl $t1,$t2,10
Shift right logical : Set $t1 to result of shifting $t2 right by number of bits specified by immediate

srlv $t1,$t2,$t3
Shift right logical variable : Set $t1 to result of shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3

# derivatives

and $t1,$t2,100
AND : set $t1 to ($t2 bitwise-AND 16-bit unsigned immediate)

and $t1,100
AND : set $t1 to ($t1 bitwise-AND 16-bit unsigned immediate)

andi $t1,$t2,100000
AND Immediate : set $t1 to ($t2 bitwise-AND 32-bit immediate)

andi $t1,100
AND Immediate : set $t1 to ($t1 bitwise-AND 16-bit unsigned immediate)

andi $t1,100000
AND Immediate : set $t1 to ($t1 bitwise-AND 32-bit immediate)

not $t1,$t2
Bitwise NOT (bit inversion)

or $t1,$t2,100
OR : set $t1 to ($t2 bitwise-OR 16-bit unsigned immediate)

or $t1,100
OR : set $t1 to ($t1 bitwise-OR 16-bit unsigned immediate)

ori $t1,$t2,100000
OR Immediate : set $t1 to ($t2 bitwise-OR 32-bit immediate)

ori $t1,100
OR Immediate : set $t1 to ($t1 bitwise-OR 16-bit unsigned immediate)

ori $t1,100000
OR Immediate : set $t1 to ($t1 bitwise-OR 32-bit immediate)
```



### 比较指令（compare）

```asm
slt $t1,$t2,$t3
Set less than : If $t2 is less than $t3, then set $t1 to 1 else set $t1 to 0

slti $t1,$t2,-100
Set less than immediate : If $t2 is less than sign-extended 16-bit immediate, then set $t1 to 1 else set $t1 to 0
```

### 访存（memory access）

```asm

lw $t1,-100($t2)
Load word : Set $t1 to contents of effective memory word address

sw $t1,-100($t2)
Store word : Store contents of $t1 into effective memory word address

# derivatives


sw $t1,($t2)
Store Word : Store $t1 contents into effective memory word address

sw $t1,-100
Store Word : Store $t1 contents into effective memory word address

sw $t1,100
Store Word : Store $t1 contents into effective memory word address

sw $t1,100($t2)
Store Word : Store $t1 contents into effective memory word address

sw $t1,100000
Store Word : Store $t1 contents into effective memory word address

sw $t1,100000($t2)
Store Word : Store $t1 contents into effective memory word address

sw $t1,label
Store Word : Store $t1 contents into memory word at label's address

sw $t1,label($t2)
Store Word : Store $t1 contents into effective memory word address

sw $t1,label+100000
Store Word : Store $t1 contents into effective memory word address

sw $t1,label+100000($t2)
Store Word : Store $t1 contents into effective memory word address


lw $t1,($t2)
Load Word : Set $t1 to contents of effective memory word address

lw $t1,-100
Load Word : Set $t1 to contents of effective memory word address

lw $t1,100
Load Word : Set $t1 to contents of effective memory word address

lw $t1,100($t2)
Load Word : Set $t1 to contents of effective memory word address

lw $t1,100000
Load Word : Set $t1 to contents of effective memory word address

lw $t1,100000($t2)
Load Word : Set $t1 to contents of effective memory word address

lw $t1,label
Load Word : Set $t1 to contents of memory word at label's address

lw $t1,label($t2)
Load Word : Set $t1 to contents of effective memory word address

lw $t1,label+100000
Load Word : Set $t1 to contents of effective memory word address 

lw $t1,label+100000($t2)
Load Word : Set $t1 to contents of effective memory word address
```

### 分支/跳转（branch/jump）

```asm
beq $t1,$t2,label
Branch if equal : Branch to statement at label's address if $t1 and $t2 are equal

bne $t1,$t2,label
Branch if not equal : Branch to statement at label's address if $t1 and $t2 are not equal

j target
Jump unconditionally : Jump to statement at target address

jal target
Jump and link : Set $ra to Program Counter (return address) then jump to statement at target address

jr $t1
Jump register unconditionally : Jump to statement whose address is in $t1

# derivatives

b label
Branch : Branch to statement at label unconditionally

beq $t1,-100,label
Branch if EQual : Branch to statement at label if $t1 is equal to 16-bit immediate

beq $t1,100000,label
Branch if EQual : Branch to statement at label if $t1 is equal to 32-bit immediate

bne $t1,-100,label
Branch if Not Equal : Branch to statement at label if $t1 is not equal to 16-bit immediate

bne $t1,100000,label
Branch if Not Equal : Branch to statement at label if $t1 is not equal to 32-bit immediate

bnez $t1,label
Branch if Not Equal Zero : Branch to statement at label if $t1 is not equal to zero
```



### IO

```asm
syscall
Issue a system call : Execute the system call specified by value in $v0
```

## 具体翻译实现



## 在此分支上的bug

不要忘记添加到readme中

+ const init时，insert顺序反了

## 参考资料

[MIPS语法教学](https://www.cnblogs.com/thoupin/p/4018455.html)

[函数调用](https://blog.csdn.net/do2jiang/article/details/5404566)



