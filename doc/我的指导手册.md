# 我的指导手册

## 文法处理

写完一个以后，就都是机械性的劳动了。

## 错误处理

建立SymbolTable类，初始化给Parser

每一个exp返回值是一个Pair，Pair第一个元素是SymbolType，第二个元素是返回值的中间代码里temp变量的名称。

数字和中间变量在中间代码的生产上，具有语义的一致性。

a+1，a+b，

转换成中间代码的时候，src2=b和src2=1都能被跑通

函数调用的四元式

```c
a = add();
a = add(1, 2);
a = add(b, c);
a = add(b+1, c);
```

解析参数表FuncRParams时，对应的是形参实参的拷贝，返回存储的名称列表

解析函数调用时，将名称列表中的参数压栈，也就是push

## 数组

数组分为常量数组和变量数组，

行为分为定义和赋值。

### 常量数组

```cpp
const int a = 1;
const int b[a+2] = {1+a, 3*4, 5+6}; // error, ConstInitVal need const
const int c[1+1][2] = {{1,2}, {2+3, 4*5}}; // correct
```

常量一定会被赋值，不存在系统提供初值的情况。

常量数组定义中，数组长度一定能够利用常量求出，注意是number组成的常量。

常量数组的值一定能供利用原来的常量求出，所以常量的值在一开始就要被填入符号表中，

将常量数组中的值全部转换为一维，填入符号表中。

### 变量数组

```cpp
int a;
int a[1+const][2+const];
int b[a+2] = {1+a, 3*4, 5+6};
int c[1+1][2] = {{1,2}, {2+3, 4*5}};
```

全局变量和局部变量，

变量只定义，则只存入符号表，当赋值时，生成四元式。

数组的长度一定可以

变量数组在赋值时，通过四元式将值一个个压入数组中

## 中间代码生成

### 常量

常量和常量数组的值直接被存入符号表中，不进行中间代码生成。

### 数组定义

### 数组初始化

OP_ARR_SAVE





### 函数定义

### 函数调用

wzk：先prepare，然后push，最后call一下，全是单目运算符，

kxh：不prepare，直接push，最后call一下，会生成tempvar，也在call里

kxh利用参数列表，重新生成中间变量再push，wzk直接push

进入ParaRList





