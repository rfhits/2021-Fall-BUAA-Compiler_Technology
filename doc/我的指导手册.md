# 我的指导手册

## 参考资料

[MIPS寄存器约定](https://hev.cc/805.html)

[注释应当遵循的规范](https://gitee.com/suse110/doxygen-sample)

[使用基本操作实现关系运算](https://stackoverflow.com/questions/20552377/implement-relational-operator-with-arithmetic-bitwise-operators)



## 文法处理

写完一个以后，就都是机械性的劳动了。

## 错误处理

建立SymbolTable类，初始化给Parser

请尤其注意文法的约束。

在18级的文法中，竟然保证不出现同名的变量，所以用map是最优解

在19级的文法中，竟然允许常量和函数同名，所以必须用vector

每一个exp返回值是一个Pair，Pair第一个元素是SymbolType，第二个元素是返回值的中间代码里temp变量的名称。

数字和中间变量在中间代码的生产上，具有语义的一致性。

a+1，a+b，

转换成中间代码的时候，src2=b和src2=1都能被跑通

函数调用的四元式

```c
a = add();
a = add(1, 2);
a = add(b, c);
a = add(b+1, c);
```

解析参数表FuncRParams时，对应的是形参实参的拷贝，返回存储的名称列表

解析函数调用时，将名称列表中的参数压栈，也就是push

## 数组

数组分为常量数组和变量数组，

行为分为定义和赋值。

### 常量数组

```cpp
const int a = 1;
const int b[a+2] = {1+a, 3*4, 5+6}; // error, ConstInitVal need const
const int c[1+1][2] = {{1,2}, {2+3, 4*5}}; // correct
```

常量一定会被赋值，不存在系统提供初值的情况。

常量数组定义中，数组长度一定能够利用常量求出，注意是number组成的常量。

常量数组的值一定能供利用原来的常量求出，所以常量的值在一开始就要被填入符号表中，

将常量数组中的值全部转换为一维，填入符号表中。

常量数组也要被填入中间代码中，因为通过变量的维度来取值。

### 变量数组

```cpp
int a;
int a[1+const][2+const];
int b[a+2] = {1+a, 3*4, 5+6};
int c[1+1][2] = {{1,2}, {2+3, 4*5}};
```

全局变量和局部变量，

变量只定义，则只存入符号表，当赋值时，生成四元式。

数组的长度一定可以

变量数组在赋值时，通过四元式将值一个个压入数组中

## 符号表

```bash
global_table
name -> table_entry
name -> |symbol_type|data_typ|name|value|dims|dim0_size|dim1_size|addr|level|array_values
name -> |symbol_type|data_typ|name|value|dims|dim0_size|dim1_size|addr|level|array_values


func_table
func_name -> |___
             |___
             |___
             |___

func_name -> |___
             |___
             |___
             |___
```

### level管理

```cpp
void foo(int a) {
    {
        int b = 1;
    }
}
```

何时level应当自增？

我们要找出分界处，函数参数定义和Block定义，所以应该是在进入前，及进行level++，即进入解析函数参数定义和解析Block前进行level++，二者内部专心管理符号表即可。

那么何时进行level--，上文提到了“专心”，所以Block内部不应当触碰level，所以还是在外部管理level

### if的作用域

```cpp
int a = 1;
int b = 1;
if (a == 1) int b = 1;
```

会报错。

if和while同理，只在函数参数和{时进行level管理

```
'if' '(' Cond ')' Stmt [ 'else' Stmt ] |
'while' '(' Cond ')' Stmt |
```

### 函数定义

### 函数参数定义

`FuncFParam -> BType Ident [ '[' ']' { '[' ConstExp ']' }]`

举个例子：

```cpp
int foo(int a, int b[], int c[][3]) {
    a = 1;
    b[2] = 1;
    c[2][2] = 1;
}
```

Question: 为什么传入二维数组时要指定地址？

Answer: 因为翻译成中间代码时候，传入的是一个数组开始的地址，要取到内部的值，需要已知第二维的长度。

上例中，`c[2][2]`的地址就是第二维，第二个，通过参数知道每一维的长度是3，所以求得偏移是`2*3+2-1`





## 中间代码生成

### 常量

常量和常量数组的值直接被存入符号表中，不进行中间代码生成。

### 数组定义

### 数组初始化

OP_ARR_SAVE





### 函数定义

### 函数调用

wzk：先prepare，然后push，最后call一下，全是单目运算符，

kxh：不prepare，直接push，最后call一下，会生成tempvar，也在call里

kxh利用参数列表，重新生成中间变量再push，wzk直接push

进入ParaRList

### 条件语句

```cpp
if (cond) 
	if-block
else 
    else-block
```

关键是生成是否跳过的`if-block`的`label`。

```asm
    BNE cond 1 else-block-label
    if-block
	Jump if-end-label
else-block-label:
    else-block
if-end-label:
```

对于没有else的语句：

```asm
    BNE cond 1 else-block-label
    if-block
else-block-label:
```

### while语句

```cpp
while_begin_label:
	calculate cond
    BNE cond 1 while_end_label
    while-block
    Jump while_begin_label
w
```







