# 代码优化

`FinalCycle = DIV * 100 + MULT * 3 + JUMP/BRANCH * 1.5 + MEM * 2.5 + OTHER * 1`

1. 寄存器分配
2. 函数内联
3. 窥孔优化
4. 循环跳转
5. 乘除优化

## 寄存器分配

大坑是基本块

我LRU写错了，应该是接口设计混乱，没有分清楚搜索什么时候kick out，什么时候move

LRU：查找时，若命中，则移动到列表的尾部，不中，则弹出头部的元素，将新的元素移动到尾部（这个地方我有bug）

删除时，直接移除头部元素

temp寄存器有时候用完可以直接删了，没必要回写

使用LRU作为寄存器的分配策略，对于每一条四元式，可以这样思考寄存器和内存之间的关系：

reg：

reg对应的数据结构是一个table和一个order

1. 什么也不做，none
2. 将一个symbol放到reg里，put
3. 将一个symbol从reg中踢出去，remove

memo：

1. 什么也不做，none
2. 将reg中的symbol写入到memo中，save
3. 将memo中的symbol写入到reg中，load

将他们排列组合，得到有意义的操作：

1. reg-none+memo_save
2. reg-put+memo_none
3. reg-put+memo_load
4. reg-remove+memo_none
5. reg-remove+memo_save

这五种操作都不需要对order进行修改，修改应该是更高抽象需要考虑的

然后我们针对四元式做需求分析：

### arith

比如add一类的指令，分两种情况：

1. dst和src完全不相同：那么，dst不需要从memo中读取，直接操作2，reg_put+memo_none，

    然后src，若在寄存器中，需要调整order，否则需要从memo中读取，再调整order

2. dst和src有相同，检查dst是否在寄存器中，若在，则直接返回，否则，put+load

归纳出两种操作：

assign_reg_require_load_from_memo

1. 检查是否在寄存器中，在直接返回
2. 若不在，从memo中读取到寄存器中，可能要踢出寄存器

assign_reg_without_load_from_memo

1. 检查是否在寄存器中，在直接返回
2. 若不在，直接放到寄存器中，不需要读取，可能要踢出寄存器

### temp

临时变量有个特点，就是用完了，如果不在基本块中再使用，就可以直接扔掉，不用回写。



get：

在不在无所谓，我需要symbol出现。

1. 如果本身就在，那么需要调整order

2. 如果本身不在，分临时和局部/全局考虑

    使用关键词assign

3. 

require load from memo



assign：保证symbol不在regs中





## 函数内联

嵌套函数的内联，解决方法，先内联一层，然后再内联



```cpp
int print(int num) {
    if (num > 0) printf("num: %d\n", a);
    return 0;
}

int sum2(int a, int b) {
    return a + b;
}

int sum3(int a, int b, int c) {
    return sum2(sum2(a,b),c);
}

int main() {
    int a = 1, b = 5, c;
    a = sum2(a,b);
    print(a);
    c = sum3(a,b,b);
    print(c);
    return 0;
}
```



```cpp
int print(int num) {
    if (num > 0) printf("num: %d\n", num);
    return 0;
}

int print_arr(int a[], int n) {
    int i = 0;
    while (i < n) {
        print(a[i]);
        i = i+1;
    }
    return 0;
}

int sum_arr(int a[], int n) {
    int i = 0, sum = 0;
    while (i < n) {
            sum = sum + a[i];
            i = i+1;
    }
    return sum;
}

int main() {
    int a = 1, b = 5;
    int c[3] = {1,2,3};
    print(sum_arr(c,3));
    return 0;
}
```



```cpp
int g_a = 1;

void print(int a) {
    printf("%d\n", a);
}

int sum(int a, int b) {
    return a+b;
}
int main() {
    int a=1,b = 2;
    int c; // cout var
    c = sum(a,b);
    print(c);
    c = sum(a,b);
    print(c);
    return 0;
}
```

```cpp
int print(int num) {
    printf("num: %d\n", num);
    return 0;
}

int sum2(int a, int b) {
    return a + b;
}

int sum3(int a, int b, int c) {
    return sum2(a, sum2(b,c));
}

int sum4(int a, int b, int c, int d) {
    return sum2(sum3(a,b,c),d);
}

int main() {
    int a = 1;
    a = sum4(a, a, a, a);
    print(a);
    return 0;
}
```



## 窥孔优化

优化完了，可以改符号表，删除无用符号

## 循环跳转

写出了一个没考虑continue的bug

## 乘除优化





