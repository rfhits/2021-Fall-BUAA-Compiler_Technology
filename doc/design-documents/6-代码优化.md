# 代码优化

1. 寄存器分配
2. 函数内联
3. 窥孔优化
4. 循环跳转
5. 乘除优化

## 寄存器分配

大坑是基本块

我LRU写错了，应该是接口设计混乱，没有分清楚搜索什么时候kick out，什么时候move

LRU：查找时，若命中，则移动到列表的尾部，不中，则弹出头部的元素，将新的元素移动到尾部（这个地方我有bug）

删除时，直接移除头部元素

temp寄存器有时候用完可以直接删了，没必要回写

## 函数内联

嵌套函数的内联，解决方法，先内联一层，然后再内联



```cpp
int print(int num) {
    if (num > 0) printf("num: %d\n", a);
    return 0;
}

int sum2(int a, int b) {
    return a + b;
}

int sum3(int a, int b, int c) {
    return sum2(sum2(a,b),c);
}

int main() {
    int a = 1, b = 5, c;
    a = sum2(a,b);
    print(a);
    c = sum3(a,b,b);
    print(c);
    return 0;
}
```



```cpp
int print(int num) {
    if (num > 0) printf("num: %d\n", num);
    return 0;
}

int print_arr(int a[], int n) {
    int i = 0;
    while (i < n) {
        print(a[i]);
        i = i+1;
    }
    return 0;
}

int sum_arr(int a[], int n) {
    int i = 0, sum = 0;
    while (i < n) {
            sum = sum + a[i];
            i = i+1;
    }
    return sum;
}

int main() {
    int a = 1, b = 5;
    int c[3] = {1,2,3};
    print(sum_arr(c,3));
    return 0;
}
```



```cpp
int g_a = 1;

void print(int a) {
    printf("%d\n", a);
}

int sum(int a, int b) {
    return a+b;
}
int main() {
    int a=1,b = 2;
    int c; // cout var
    c = sum(a,b);
    print(c);
    c = sum(a,b);
    print(c);
    return 0;
}
```

```cpp
int print(int num) {
    printf("num: %d\n", num);
    return 0;
}

int sum2(int a, int b) {
    return a + b;
}

int sum3(int a, int b, int c) {
    return sum2(a, sum2(b,c));
}

int sum4(int a, int b, int c, int d) {
    return sum2(sum3(a,b,c),d);
}

int main() {
    int a = 1;
    a = sum4(a, a, a, a);
    print(a);
    return 0;
}
```



## 窥孔优化

优化完了，可以改符号表，删除无用符号

## 循环跳转

## 乘除优化

## todo

可以做一个init的四元式，这样避免了初始化时add采用的load





